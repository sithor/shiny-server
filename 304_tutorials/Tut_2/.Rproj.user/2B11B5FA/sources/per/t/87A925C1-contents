---
title: "Getting started with Rstudio!"
author: "Simon Thornley"
date: "`r format(Sys.time(), '%e %B, %Y')`"
output: 
  learnr::tutorial:
        progressive: true
        allow_skip: true
  # prettydoc::html_pretty:
  #               theme: tactile
runtime: shiny_prerendered
description: >
  Inspecting our data for errors!
---

```{r setup, include=FALSE}
library(learnr)
library(tufte)
library(rio)
library(visdat)
library(fs)
library(ggplot2)
library(DiagrammeR)
library(r2symbols)
library(learnr)
library(gradethis)
library(skimr)
gradethis::gradethis_setup()
df <- rio::import("https://flexiblelearning.auckland.ac.nz/data-analysis/menu/1/files/simple_sids_epiinfo2.xlsx")

df_no_dups <- df[!duplicated(df),]

#df <- rio::import("https://flexiblelearning.auckland.ac.nz/data-analysis/menu/1/files/simple_sids_epiinfo2.xlsx")
#dir.create("./data")
#rio::export(df, "./data/sids.xlsx")

# tutorial_options(
#   exercise.timelimit = 60,
#   # A simple checker function that just returns the message in the check chunk
#   exercise.checker = function(check_code, ...) {
#     list(
#       message = eval(parse(text = check_code, ...)),
#       correct = logical(0),
#       type = "info",
#       location = "append"
#     )
#   }
# )
knitr::opts_chunk$set(error = TRUE)
```
<br> </br>
<center>![Out of my depth](images/kristopher-roller-PC_lbSSxCZE-unsplash.jpg "Photo by Kristopher Roller on Unsplash.com"){#id .class width="50%" height="50%"}</center>

# Getting started with R

In the [last session](https://sithor.shinyapps.io/POPLHLTH_304_Tutorial_1/){target="_blank"}, we discussed some basic concepts related to the use of [`R`](https://cran.r-project.org/){target="_blank"} for statistical computing.

This session, we will focus on continuing to take baby steps with `R` and revise and develop some of the concepts from the last tutorial.

We are going to take a plunge in the grown-up world of statistical computing and coding. This can be nerve wracking, but with a bit of practice, I think you'll find it deeply satisfying, and it will open up many different career opportunities.

<center>![Diving in](images/simone-mascellari-XnN42lsNv28-unsplash.jpg "Photo by Simone Mascellari on Unsplash.com"){#id .class width="50%" height="50%"}</center>

We will learn how to:

-   navigate the posit`r sym("trademark")` interface
-   load libraries
-   import data
-   check the integrity of our data.

## Navigating the posit`r sym("trademark")` interface

In this session, we will be practising some coding on the web, but ultimately, we want to build some confidence with [Posit](https://posit.co/){target="_blank"},`r sym("trademark")` an integrated development environment or IDE for coding `R`. You can download a free version of Posit to run on your Windows or Mac computer or as we will do in this course, we will use [Posit cloud](https://posit.cloud/project/3679722){target="_blank"}.`r sym("trademark")` You will need to sign-up for an account, but if you use less than 25 hours per month, it will be free. The terms of the free account are [here](https://posit.cloud/plans/free){target="_blank"}. The benefit of using Posit cloud`r sym("trademark")` is that we don't have to install anything, and sometimes there are problems with permissions that can cause trouble for students starting out. Our aim here is keep things as *simple* as possible.

<center>![Headache](images/vinicius-amnx-amano-DZ0MfTX_9sQ-unsplash.jpg "Photo by Kristopher Roller on Unsplash.com"){#id .class width="50%" height="50%"}</center>

Using `R` and `posit` `r sym("trademark")` can be unforgiving. It is **case-sensitive** and if you don't get the `function` and `object` names exactly **right**, `R` will not understand what you are trying to tell it. `R`, although very sophisticated, is a super dumb machine! It carries out to the letter exactly what you tell it to do. Please bear this in mind next time you are troubleshooting with it!

Also, it is useful to litter your code with comments, so that if you forget what your code is doing, you can read your comments to explain what is happening. When you are coding, you have to bear in mind your forgetful future self! These can be done, simply by using a `#` sign in front of what you are writing.

`posit` has four different parts and at first it can be a bit intimidating. Let's explore the different parts of the program before we start.

<center>![Orientating yourself to posit](images/Rstudio.png)</center>

### What are the four different panes in posit`r sym("trademark")`?

It seems strange, but the `Source` pane sends commands to the `Console`. This is so that you have a record of what you've done as your `Source` file, which is simply plain text. The file extension, which is the type of file you create when working with `R` is a `.R` file. The `Console` is like the brains of the operation and executes your commands from the upper `Source` window. The right upper pane shows the `objects`s or *datasets* or other objects that we are working on and the bottom right pane has different tabs to see our files, plots, packages and help.

### Why use code?

Most of us are probably familiar with 'point and click' computer programs that hide a lot of the complexity of computer commands from us. This is what we were using with [iNZight](https://inzight.nz/){target="_blank"} in `POPLHLTH 216`. They are generally very good for many things. One of the problems, however, with 'point and click' systems is that they don't easily allow you to see a record of what you have done to share with others (reproducibility), and they make it difficult to redo a series of complex commands that may need to be updated. Data analysis for epidemiology often requires reproducibility and so coding is often necessary.

### Test your understanding...

```{r basics, echo=FALSE}
question("Which of the following windows or '*panes*' do we write code into when we use `posit`?",
  answer("`Source` (top left)", correct = TRUE, message = "Yes, this is the text file that will do its work on various objects, such as a spreadsheet of epidemiological data."),
  answer("`Console` (bottom left)", message = "No, this is where you'll see the output from your `Source` panel."),
  answer("`Environment` (upper right)", message = "No, this is the various objects that are in your workspace."),
  answer("`Files, plots, Packages, Help` pane (bottom right)",  message = "No, this is where we produce plots, or look for files that we can access or see help related to a function we trying to use."),
  allow_retry = TRUE
)
```

Ok, so now we know something about how our interface will work.

## Loading libraries

`R` is like a 'go cart' that many, many, many people have contributed to and has been turned into a Rolls-Royce. Basic mathematical and statistical `functions` are 'built-in' to `R`, but libraries are little 'packages' of code with additional `functions` that allow us to extend the use of `R`.

Four libraries will help us achieve our goals today will be:

```{r eval = FALSE}
rio

```

which helps us import a variety of datasets. See [here](https://www.rdocumentation.org/packages/rio/versions/0.5.29){target="_blank"} for more information.

```{r eval = FALSE}
visdat
```

This helps us see missing data in our `data.frame` in a visual manner.

```{r eval = FALSE}
skimr
```

`skimr` is a package for summarising our data.frame. See more information [here](https://docs.ropensci.org/skimr/articles/skimr.html){target="_blank"}.

To install libraries, we need to be connected to the **internet**!

To install and load libraries in R we use the following code:

```{r eval = FALSE}
install.packages("rio")
library(rio)
```

This is the simple way. If you have already loaded `rio`, then a way to not have to re-install it is with a bit more code that I'll use quite frequently:

```{r eval = FALSE}
if(!require(rio)) install.packages("rio")
library(rio)
```

This is a bit complex, but illustrates a useful function. In computing we can make the computer do stuff if a certain condition is fulfilled. This is called *conditional logic*. It is vitally important.

The

```{r eval = FALSE}
if(!require(rio)) 
```

bit, is saying "*have a look and see whether you already have the `rio` package*". The

```{r eval = FALSE}
require(rio) 
```

bit will return a logical value of `TRUE` if it is already loaded in your computer, and `FALSE` if not. We only want the computer to install the library if it isn't already installed. If it is not there, the result of `require(rio)` will be `FALSE`. The `if` function only executes the following function if `TRUE`, so we need to turn the `TRUE` into a `FALSE` and vice versa. This is what the `!` does. Don't worry if you don't get this. It is a bit of magic that saves you a bit of time loading new libraries! The `if` statement means that the `install.packages()` code only runs if you don't have `rio` already installed. When you have lots of packages to load, you'll find this very handy!

```{r eval = FALSE}
library(rio) 
```

bit makes sure that the `R` console can find the function we are after. For example, if we are wanting to use the `import()` function from the `rio` package, if we haven't typed `library(rio)` we will have to tell `R` where to find the `import()` function with the following code...

```{r eval = FALSE}
rio::import("./path/to/csv or Excel file.csv") 
```

With the `library(rio)` call, we can now more simply type:

```{r eval = FALSE}
import("./path/to/csv or Excel file.csv") 
```

### Test your understanding...

```{r libraries, echo=FALSE}
question('If we have want to use the `import` function in the `rio` package, and have installed with `install.packages("rio")`, but we haven\'t called `library(rio)`, how can we make sure `R` can find the function?',
  
  answer("use `rio::import()`", correct = TRUE, message = "Yes, this tells `R` to look in the `rio` package for the `import()` function."),
  answer("use `import()`", message = "No, because the `rio` package is not loaded, `R` doesn't know where to look for this function. You could use this option if you first ran the code: `library(rio)`"),
  allow_retry = TRUE
)

```

In the following exercise, please write some code to install the `epiDisplay` library if it is not already installed on your machine.

```{r load_epiDisplay, exercise = TRUE}
if (!require()) install.packages()
library()
```

```{r load_epiDisplay-solution}
if (!require(epiDisplay)) install.packages("epiDisplay")
library(epiDisplay)
```

::: {#load_epiDisplay-hint}
**Hint:** You need to include quotes around `epiDisplay` for `install.packages()`, but not for `require` or `library`.
:::

```{r load_epiDisplay-check}
grade_this_code("Well done, it is a vital skill to install and load new libraries in `R`!")
```

### 

Note the use of quotation marks ("") in the `install.packages()` function call.

These are not required in the `require()` and `library()` function calls. If in doubt check the help, by entering:

`?library` and `?install.packages`

into the console. You should see the help menu start up.

Note in the `library` help, the first argument (`pkgs`) is a *literal name* (text without quotation marks), whereas for `install.packages` the first argument is a *character vector* which means that quotation marks are needed. If in doubt, check the `Examples` at the bottom of the `help` documentation, where it is usually pretty clear what to do.

Well done. This is important for getting `R` set-up for analysis.

## File paths

Notice that we have introduced the concept of **file paths**.

**File paths** are important and tell you where on a computer a file resides, a bit like an address tells you where on the earth a house is located. Without them, we will soon get very lost!!

A good summary of the intricacies of file paths is given [here](https://www.r4epi.com/file-paths.html){target="_blank"}. In fact, the e-book available at [www.r4epi.com](https://www.r4epi.com/index.html){target="_blank"} is a very useful resource for basic `R` coding tips.

Another concept is that `file paths` can be either `relative` or `absolute`. In fact, the file I'm writing this tutorial on has a path. This path is on my USB stick:

`E:\Teaching\304\2023\Learn_R_tutorials\Tutorial_2`

You can see that I store this file on my

-   USB drive labelled `E:\`
-   Then in the `Teaching` directory or folder
-   Then in the `304` directory
-   Then in the `2023` directory
-   Then in the `Learn_R_tutorials` directory
-   Then in the `Tutorial_2` directory.

This is a bit like an address for example to Auckland University here in Grafton. Start in **New Zealand**, then head to **Auckland**, then the suburb of **Grafton** and then **Park Road**. Then go to **number 22**.

<center>![Building 507](images/1625096925935.jpg "Photo by Simon Devitt"){#id .class width="75%" height="75%"}</center>

Each part of the path is like an address. The `E:\` is the letter assigned by the Windows`r sym("trademark")` operating system to my USB stick. The hard disk for this computer or any computer running Windows`r sym("trademark")` is `C:\`. Instead on a Mac`r sym("trademark")`, the hard disk path is simply denoted by `/`. This is something that often poses a lot of confusion for people getting started in programming. If you can distinguish between a forward slash (`/`) and a back slash (`\`) and grasp when one is used over the other, you are getting off to a good start!

Most of my stuff on my Mac is stored in the `/Users/simonthornley/Documents` directory for example.

A tricky quirk of R... [there are many...](https://www.burns-stat.com/pages/Tutor/R_inferno.pdf) is that the `\` character is used in R to denote ["escape"](https://www.w3schools.com/r/r_strings.asp#:~:text=An%20escape%20character%20is%20a,character%20you%20want%20to%20insert.) characters. Therefore, I recommend converting `\` to forward slash (`/`) in R.

### Test your understanding...

```{r windows_paths, echo=FALSE}
question('You have a file with the following file path on Windows: `C:\\Users\\simonthornley\\Documents\\bigEpiStudy.xlsx`. You wish to open it in R using the `import` command, which has the format `import("path/to/file")`. What would be the most appropriate command to use in `R`?',
  answer('`import("C:/Users/simonthornley/Documents/bigEpiStudy.xlsx")`', correct = TRUE, message = "Yes, note the need to convert '`\\`' to '`/`.' in the path"),
  answer('`C:/Users/simonthornley/Documents/bigEpiStudy.xlsx`', message = "No, you need to use `import()`"),
  answer('`import("C:\\Users\\simonthornley\\Documents\\bigEpiStudy.xlsx")`', message = "No, you need to convert '`\\`' to '`/`.'"),
  allow_retry = TRUE
)
```

### Relative and absolute file paths

Both of these paths are considered **absolute**. When you start to use `R` however, we can use a short cut. For example, now, I'm writing this tutorial in the `E:\Teaching\304\2023\Learn_R_tutorials\Tutorial_2` folder of my USB drive. This is where `R`'s 'working directory' is. So, if I want to add in an image from the `E:\Teaching\304\2023\Learn_R_tutorials\Tutorial_2\images` directory, I tell R not to look at the whole absolute path, but rather look at the current working directory and then go into the `images` subdirectory. The **relative** file path is given by `./images`. The `./` says look in the current directory. The use of **relative** paths is encouraged as it makes code more portable between different computers.

### Test your understanding...

```{r posit_basics, echo=FALSE}
question("Which of the following windows or '*panes*' do we write code into when we use `posit`?",
  answer("`Source` (top left)", correct = TRUE, message = "Yes, this is the text file that will do its work on various objects, such as a spreadsheet of epidemiological data."),
  answer("`Console` (bottom left)", message = "No, this is where you'll see the output from your `Source` panel."),
  answer("`Environment` (upper right)", message = "No, this is the various objects that are in your workspace"),
  answer("`Files, plots, Packages, Help` pane (bottom right)",  message = "No, this is where we produce plots, or look for files that we can access or see help related to a function we trying to use."),
  allow_retry = TRUE
)

```

## Importing and inspecting our data

The final step involves three aspects of the data that I think are important to look for.

These are:

-   duplicates
-   missing data
-   ranges

We want to avoid the situation which can happen in research of garbage in, garbage out. It is much, much more preferable to pick up problems before they occur.

### Check your understanding...

```{r checks, echo=FALSE}
question("What are the three most important issues to consider when you import data into R?",
  answer("Statistical significance, exposure and confounding variables are present.", message = "These are useful to know, but not crucial at the first stage!"),
  answer("Format of data, number of observations, type of study", message = "These are important, but not crucial for avoiding errors!"),
  answer("Length of dataset, number of variables, missing values", message = "One is correct... the first two are useful to know, but not crucial"),
  answer("Duplicates, missing values and range checks", correct = TRUE, message = "Well done, these are important to consider"),
  allow_retry = TRUE
)
```

## Importing our data

We will import some data from the internet, using a `URL` rather from our local machine, using a file path. It is a cot-death dataset. We will talk about what it means later, but for now will just dive in to have a look at the data. It was a *case-control* study to look for risk factors for cot-death in the 1980s. Suspected causes were:

-   bed-sharing
-   maternal smoking
-   sleeping position

### Subjects in the study

These were women whose infants suffered from unexplained death that fulfilled the definition of **cot-death**. Controls were from randomly selected women with normal healthy babies, which were matched for age and ethnicity.

We will use the following code:

**Note**: This assumes that we have the `rio` package installed on our machine!

```{r eval = FALSE}
df <- rio::import("https://flexiblelearning.auckland.ac.nz/data-analysis/menu/1/files/simple_sids_epiinfo2.xlsx")
```

Here, the URL `"https://flexiblelearning.auckland.ac.nz/data-analysis/menu/1/files/simple_sids_epiinfo2.xlsx"` is an **argument** or modifier to the function that pulls in the data we want (`import`). The argument tells `rio::import` where to look on the internet for the dataset. This is a very efficient way of getting data into R. It skips all the hunting on the internet for the data and downloading onto our computer.

If we search in the `import` documentation using the code `?import`, we see that the first argument indicates that it should be *character string*, meaning it should be in quotes, and it can be either a:

-   **file** (use a path to a file on your local computer)
-   **URL** (address to a file on the internet)
-   or `.zip` or `.tar` archive. These are types of compressed files.

The relevant part of the help is shown below

<center>![Help for rio function](images/rio_import.PNG)</center>

If you are using posit,`r sym("trademark")` then you will You will see our object up on the top right pane (`Environment/History`).

You can then double click it to see what it looks like in a mode similar to Excel.`r sym("trademark")`

## Checking for duplicates

We can now have a look for duplicates in the `df` object which incorporates our data pulled in from an Excel`r sym("trademark")` sheet. To accomplish this feat, we will need to dive into subsetting. In the picture below we see a visual representation of a spreadsheet or `data.frame` in the `R` world. We see that the square brackets (`[]`) after the object name are used for subsetting. Code is separated within the square brackets by a comma.

-   Code **before** the comma subsets rows (individuals in epidemiology)
-   Code **after** the comma subsets columns (variables or exposures or confounders in epidemiology)

<center>![Visual illustration of subsetting from https://www.guru99.com/r-data-frames.html](images/032918_1452_RDataFrames2.jpg)</center>

You can see that the `1:2` code before the comma ([green]{style="color: green;"} arrow) in the square brackets selects the first two rows. The `1` after the comma indicated by the [red]{style="color: red;"} arrow, selects the first row. Note that if there is no code before the comma, all rows are selected. The [blue]{style="color: blue;"} and [yellow]{style="color: #8B8000;"} arrows shows a combination of subsetting being used.

#### Your turn

In the pane below, import the data and then subset the first observation, and then the first column. Finally, subset both the first observation and the first column in the same line of code. You should write three lines of code in total.

```{r subset, exercise = TRUE}
df <- rio::import("https://flexiblelearning.auckland.ac.nz/data-analysis/menu/1/files/simple_sids_epiinfo2.xlsx")

```

```{r subset-solution}
df <- rio::import("https://flexiblelearning.auckland.ac.nz/data-analysis/menu/1/files/simple_sids_epiinfo2.xlsx")
df[1, ]
df[ , 1]
df[1, 1]
```

::: {#subset-hint}
**Hint:** You need to use square brackets, with numbers **before** the comma selecting rows, and **after** the comma selecting columns
:::

```{r subset-check}
grade_this_code("Well done :) It is a vital skill to subset `data.frames` in `R`")
```

If you managed the last exercise, you will have seen that the first column is a `Case status`, and the first row of the first column is a `control`. The first observation in the dataset was for a control, a male Pacific child, 4.8 weeks old, with a birth weight of 680 grams. That is very light!

That is the introduction. To look for duplicates, we will get `R` to check every subject in the `data.frame` and ensure that they are do not have the same value for each exposure or column. It will build on the subsetting idea. We will use the `duplicated` function. If we give the first argument to `duplicated` as the data.frame (`df`), it will check to see which rows have exactly the same values. The way `duplicated` works is that it checks each row for another match and then

In a very large study, it is of course possible that a random individual has exactly the same values for all variables, but this is highly unlikely, particularly when continuous variables are included.

We also introduce a powerful concept here, that of piping. If we find duplicates, as we have in this data set, we may want to summarise how many rows are duplicated to give us an idea of how widespread the problem is. We do this with another function called `nrow()` which counts the number of rows in a given `data.frame`. The pipe allows us to use the previous code as an input (or argument) to a new function (here `nrow`). The pipe has an unusual look to it (`|>`). The same idea can be accomplished by using brackets, but it looks more cumbersome. Nested brackets soon cause trouble for complicated operations. The thing to remember about the pipe is that it assumes that your previous code is the **first** argument to your next function. If it is not the first argument, you may have to use the underscore (`_`) placeholder.

Notice, also that in creating the new data.frame with no duplicates, we use the exclamation mark (`!`). This is because the output of `duplicated(df)` returns a logical value of `TRUE` if the row is duplicated and `FALSE` if not. That list or technically, a `vector` of logical values tells `R` what rows to keep (`TRUE`) and which to discard (`FALSE`) in the data.frame.

We would like to retain all subjects (rows) that are **not** duplicated. The way to change a `TRUE` to a `FALSE` and vice versa is to use the `!` operator.

Run the code below to check it for duplicates. Is there any?

```{r check_dups, exercise = TRUE}

df[duplicated(df), ]

## Pipe, to find the number of rows that are duplicated

df[duplicated(df),] |> nrow()

## Old-fashioned version of above, with brackets.

nrow(df[duplicated(df),])

## Remove duplicate rows from data.frame

df_no_dups <- df[!duplicated(df), ]

```

Enter the number of duplicates into R below to make sure you've got the right information...

```{r check_dups_rev, exercise = TRUE}

```

```{r check_dups_rev-solution}
3

```

```{r check_dups_rev-check}
grade_this({
  # custom checking code appears here
  if (identical(.result, .solution)) {
    pass("Great work!")
  }
  fail("Try again!")
})
```

As a final exercise for this section, see if you can calculate the proportion of rows of the original file that are duplicated in `R`, using code.

```{r prop_dups_rev, exercise = TRUE}

```

```{r prop_dups_rev-solution}
1 - (df_no_dups |> nrow())/(df |> nrow())

```

::: {#prop_dups_rev-hint}
**Hint:** You will have to estimate the number of rows in the dataset with duplicates, divided by the original. The difference from this proportion is taken from one to give the proportion of observations that are duplicated.
The solution is here `1 - (df_no_dups |> nrow())/(df |> nrow())`
:::

```{r prop_dups_rev-check}
grade_this({
  # custom checking code appears here
  if (identical(.result, .solution)) {
    pass("Fantastic, this was a tricky one! 0.00016 or 0.016%")
  }
  fail("Try again!")
})
```

We generally want to identify and get rid of duplicates. It is sometimes hard to figure out what the best way of identifying duplicates are. If there is a unique identifier, this makes it easier.

## Checking extreme values or ranges

The `skim` function from the `skimr` package is used to check ranges although there are many ways of doing this.

Now that we have the `df_no_dups` `data.frame`, call the `skim` function on this object. I encourage you to use the pipe (`|>`) function. Also, assume that `skimr` is installed and loaded in your session with the `library(skimr)` function call.

```{r range, exercise = TRUE}



```

```{r range-solution}

df_no_dups  |> skimr::skim()

```

```{r range-check}
grade_this({
  # custom checking code appears here
  if (identical(.result, .solution)) {
    pass("Fantastic, you are getting the hang of this, keep it up :)")
  }
  fail(paste0("Please try again! ", sym(":(")))
})
```

Check the output, do you see any implausible values? How might you investigate if you were uncertain.

Although this is a relatively clean dataset, I've lost count of the number of times I've dealt with datasets from seemingly "official" sources that have negative values for age or duplicates or whatever. I encourage you to get into the practice of checking all data before doing serious analysis on it.

## Missing data

Missing data is a big topic. Here we are just going to acknowledge it briefly and move on! Generally, we are most concerned about our *exposure*, *outcome* and important *confounder* variables. We are concerned that there are less than about 15% missing values for each of these variables. The most important variables are the exposure and outcome, but if we are building a model with many confounders, these variables may also be important. Why is this? Well, statistical software is not very sophisticated at dealing with missing data, and if an item for exposure or outcome is missing it will just drop this observation out of the analysis. If you are doing an analysis with several variables, you may inadvertantly drop many observations from your analysis.

The best function I've found for visualising missing data is `vismiss()` from the `visdat` package. Please call this on our cleaned up data.frame (`df_no_dups`) in the pane below. There is nothing fancy about it, the data.frame is the first argument to the function.

```{r miss, exercise = TRUE}



```

```{r miss-solution}

df_no_dups |> visdat::vis_miss()

```

::: {#miss-hint}
**Hint:** Pass the `df_no_dups` data.frame to the `visdat::vis_miss()` function, using the pipe (`|>`).
:::

```{r miss-check}
grade_code("&#128512;", "&#129318")
```

An improved version, with some fancy code is given below

```{r miss_clean}
(df_no_dups  |> visdat::vis_miss() ) +
  ggplot2::theme(plot.margin = unit(c(1,3,1,1), "cm"))

```

You can see that the proportion of missing data is low except for the last variable. You wouldn't want to include the last variable in an analysis as this would wipe out almost all of your data! Good to know!

## Homework

I encourage you to reproduce the steps we have taken here in an `R` script in `posit` on your laptop, to make sure you can get it working in the real world, should you need to!
